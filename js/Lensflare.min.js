import { AdditiveBlending as b, Box2 as c, BufferGeometry as d, Color as e, FramebufferTexture as f, InterleavedBuffer as g, InterleavedBufferAttribute as h, Mesh as a, MeshBasicMaterial as i, RawShaderMaterial as j, Vector2 as k, Vector3 as l, Vector4 as m, RGBAFormat as n } from "./three.module.js"; class Lensflare extends a { constructor() { super(Lensflare.Geometry, new i({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0; let t = new l, r = new l, s = new f(16, 16, n), o = new f(16, 16, n), u = Lensflare.Geometry, v = new j({ uniforms: { scale: { value: null }, screenPosition: { value: null } }, vertexShader: "\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}", fragmentShader: "\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}", depthTest: !0, depthWrite: !1, transparent: !1 }), p = new j({ uniforms: { map: { value: s }, scale: { value: null }, screenPosition: { value: null } }, vertexShader: "\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}", fragmentShader: "\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}", depthTest: !1, depthWrite: !1, transparent: !1 }), d = new a(u, v), y = [], h = LensflareElement.Shader, x = new j({ uniforms: { map: { value: null }, occlusionMap: { value: o }, color: { value: new e(16777215) }, scale: { value: new k }, screenPosition: { value: new l } }, vertexShader: h.vertexShader, fragmentShader: h.fragmentShader, blending: b, transparent: !0, depthWrite: !1 }), g = new a(u, x); this.addElement = function (t) { y.push(t) }; let w = new k, P = new k, M = new c, V = new m; this.onBeforeRender = function (e, n, i) { e.getCurrentViewport(V); let a = V.w / V.z, l = V.z / 2, c = V.w / 2, f = 16 / V.w; if (w.set(f * a, f), M.min.set(V.x, V.y), M.max.set(V.x + (V.z - 16), V.y + (V.w - 16)), r.setFromMatrixPosition(this.matrixWorld), r.applyMatrix4(i.matrixWorldInverse), !(r.z > 0) && (t.copy(r).applyMatrix4(i.projectionMatrix), P.x = V.x + t.x * l + l - 8, P.y = V.y + t.y * c + c - 8, M.containsPoint(P))) { e.copyFramebufferToTexture(P, s); let n = v.uniforms; n.scale.value = w, n.screenPosition.value = t, e.renderBufferDirect(i, null, u, v, d, null), e.copyFramebufferToTexture(P, o), (n = p.uniforms).scale.value = w, n.screenPosition.value = t, e.renderBufferDirect(i, null, u, p, d, null); let r = -2 * t.x, a = -2 * t.y; for (let n = 0, s = y.length; n < s; n++) { let s = y[n], o = x.uniforms; o.color.value.copy(s.color), o.map.value = s.texture, o.screenPosition.value.x = t.x + r * s.distance, o.screenPosition.value.y = t.y + a * s.distance, f = s.size / V.w; let l = V.w / V.z; o.scale.value.set(f * l, f), x.uniformsNeedUpdate = !0, e.renderBufferDirect(i, null, u, x, g, null) } } }, this.dispose = function () { v.dispose(), p.dispose(), x.dispose(), s.dispose(), o.dispose(); for (let t = 0, e = y.length; t < e; t++)y[t].texture.dispose() } } } class LensflareElement { constructor(t, n = 1, i = 0, r = new e(16777215)) { this.texture = t, this.size = n, this.distance = i, this.color = r } } LensflareElement.Shader = { uniforms: { map: { value: null }, occlusionMap: { value: null }, color: { value: null }, scale: { value: null }, screenPosition: { value: null } }, vertexShader: "\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}" }, Lensflare.Geometry = function () { let t = new d, e = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]), n = new g(e, 5); return t.setIndex([0, 1, 2, 0, 2, 3]), t.setAttribute("position", new h(n, 3, 0, !1)), t.setAttribute("uv", new h(n, 2, 3, !1)), t }(); export { Lensflare, LensflareElement };